'use strict';

import { trainingModule } from './course.js';

const SCORM_API_VERSION = "1.2/2004 v1.1.0";
const LOG_DIR = '/training/logs/';
let logFileName = '';
let loggingEnabled = false;

if (typeof trainingModule === 'undefined') {
    throw new Error("TrainingModule is inaccessible from within SCORM_API.js.");
}

window.SCORM_API_VERSION = SCORM_API_VERSION;

// Optional debug output
const showConsole = (msg) => { /* trainingModule.showDebug(msg, 'info') */ };

// Callback for cmi.success_status changes (2004)
let onSuccessStatusChange = null;
export function setSuccessStatusChangeHandler(fn) {
    onSuccessStatusChange = fn;
}

/**
 * Utility: Get current UTC timestamp in YYYYMMDD_HHMMSS format
 */
function getTimestamp() {
    const pad = n => n.toString().padStart(2, '0');
    const d = new Date();
    return `${d.getUTCFullYear()}${pad(d.getUTCMonth() + 1)}${pad(d.getUTCDate())}_${pad(d.getUTCHours())}${pad(d.getUTCMinutes())}${pad(d.getUTCSeconds())}`;
}

/**
 * Utility: Rename old log file and create a new one.
 * This is a stub; replace with your server-side or browser API as needed.
 */
async function rotateLogFile() {
    if (logFileName) {
        const newName = `${LOG_DIR}scorm_log_${getTimestamp()}.log`;
        // await yourRenameFunction(logFileName, newName);
    }
    logFileName = `${LOG_DIR}scorm_log_${getTimestamp()}.log`;
    // await yourCreateFileFunction(logFileName);
}

/**
 * Utility: Write to log file
 * This is a stub; replace with your server-side or browser API as needed.
 */
async function logEvent(msg) {
    if (!loggingEnabled) return;
    const logLine = `[${new Date().toISOString()}] ${msg}\n`;
    // await yourAppendFunction(logFileName, logLine);
    // Fallback for demonstration:
    console.log(logLine);
}

/**
 * Enable or disable logging
 */
export function setLogging(enabled = true) {
    loggingEnabled = enabled;
}

/**
 * Validate allowed values for key SCORM elements.
 * Returns error string if invalid, otherwise empty string.
 */
function validateSCORMValue(element, value, version = "2004") {
    // Extend as needed for other elements
    const allowed = {
        "cmi.success_status": ["passed", "failed", "unknown"],
        "cmi.completion_status": ["completed", "incomplete", "not attempted", "unknown"],
        "cmi.core.lesson_status": ["passed", "completed", "failed", "incomplete", "browsed", "not attempted"],
    };
    if (allowed[element]) {
        if (!allowed[element].includes(value)) {
            return `Invalid value "${value}" for ${element}`;
        }
    }
    return "";
}

// --------------------------------------
// SCORM 1.2 RS&I API Implementation
// --------------------------------------
(async function () {
    await logEvent(`[v${SCORM_API_VERSION}] SCORM 1.2 API Initialized`);

    const defaultData = {
        "cmi.interactions": [],
        "cmi.interactions._count": "0",
    };

    window.API = {
        data: { ...defaultData },
        errorCode: '0',
        diagnostic: '',

        LMSInitialize(param) {
            this.errorCode = param === '' ? '0' : '201';
            logEvent(`LMSInitialize called with param: "${param}"`);
            if (param === '') {
                trainingModule.saveCourse(this.data);
                logEvent('Course data saved on initialize.');
                // Optionally rotate log per session:
                // rotateLogFile();
            }
            return String(param === '');
        },

        LMSFinish(param) {
            this.errorCode = param === '' ? '0' : '201';
            logEvent(`LMSFinish called with param: "${param}"`);
            if (param === '') {
                trainingModule.close(this.data);
                logEvent('Course data saved on finish.');
            }
            return String(param === '');
        },

        LMSGetValue(element) {
            this.errorCode = '0';
            let value = '';
            if (element === "cmi.interactions._count") {
                value = String(Array.isArray(this.data["cmi.interactions"]) ? this.data["cmi.interactions"].length : 0);
            } else {
                const match = element.match(/^cmi\.interactions\.(\d+)\.(\w+)$/);
                if (match) {
                    const idx = parseInt(match[1], 10);
                    const field = match[2];
                    if (
                        Array.isArray(this.data["cmi.interactions"]) &&
                        this.data["cmi.interactions"][idx] &&
                        this.data["cmi.interactions"][idx][field] !== undefined
                    ) {
                        value = this.data["cmi.interactions"][idx][field];
                    } else {
                        this.errorCode = '401';
                        value = '';
                    }
                } else {
                    value = this.data[element] !== undefined ? String(this.data[element]) : '';
                }
            }
            logEvent(`LMSGetValue called for "${element}": "${value}"`);
            return value;
        },

        LMSSetValue(element, value) {
            this.errorCode = '0';
            let msg = `LMSSetValue called for "${element}" with value "${value}"`;

            // Validate values for key SCORM fields
            const validationMsg = validateSCORMValue(element, value, "1.2");
            if (validationMsg) {
                this.errorCode = '406';                                                                                 // Type mismatch or value out of range
                msg += ` [Validation error: ${validationMsg}]`;
                logEvent(msg);
                return 'false';
            }

            // Handle interactions
            const match = element.match(/^cmi\.interactions\.(\d+)\.(\w+)$/);
            if (match) {
                const idx = parseInt(match[1], 10);
                const field = match[2];

                if (!Array.isArray(this.data["cmi.interactions"])) {
                    this.data["cmi.interactions"] = [];
                }
                while (this.data["cmi.interactions"].length <= idx) {
                    this.data["cmi.interactions"].push({});
                }
                this.data["cmi.interactions"][idx][field] = value;
                this.data["cmi.interactions._count"] = String(this.data["cmi.interactions"].length);

                msg += ` (interaction index ${idx} field ${field})`;
            } else {
                this.data[element] = value;
            }
            logEvent(msg);
            return 'true';
        },

        LMSCommit() {
            this.errorCode = '0';
            logEvent('LMSCommit called. Data committed.');
            trainingModule.saveCourse(this.data);
            return 'true';
        },

        LMSGetDiagnostic(param) {
            this.errorCode = '0';
            logEvent(`LMSGetDiagnostic called with param: "${param}"`);
            return 'true';
        },

        LMSGetLastError() {
            logEvent(`LMSGetLastError called. Error: "${this.errorCode}"`);
            return this.errorCode;
        },

        LMSGetErrorString(errorCode) {
            let errorString = '';
            switch (errorCode) {
                case '0': errorString = 'No error'; break;
                case '101': errorString = 'General exception'; break;
                case '201': errorString = 'Invalid argument error'; break;
                case '202': errorString = 'Element cannot have children'; break;
                case '203': errorString = 'Element not an array. Cannot have count.'; break;
                case '301': errorString = 'Not initialized'; break;
                case '401': errorString = 'Not implemented error'; break;
                case '402': errorString = 'Invalid set value, element is a keyword'; break;
                case '406': errorString = 'Data Model Element Type Mismatch'; break;
                default: errorString = 'Unknown error';
            }
            logEvent(`LMSGetErrorString called for "${errorCode}": "${errorString}"`);
            return errorString;
        },
    };
})();


// --------------------------------------
// SCORM 2004 RS&I API Implementation
// --------------------------------------
(async function () {
    await logEvent(`[v${SCORM_API_VERSION}] SCORM 2004 API Initialized`);

    const defaultData = {
        "cmi.interactions": [],
        "cmi.interactions._count": "0",
    };

    window.API_1484_11 = {
        data: { ...defaultData },
        errorCode: '0',
        diagnostic: '',

        Initialize(param) {
            this.errorCode = param === '' ? '0' : '201';
            logEvent(`Initialize called with param: "${param}"`);
            if (param === '') {
                trainingModule.saveCourse(this.data);
                logEvent('Course data saved on initialize.');
                // Optionally rotate log per session:
                // rotateLogFile();
            }
            return String(param === '');
        },

        Terminate(param) {
            this.errorCode = param === '' ? '0' : '201';
            logEvent(`Terminate called with param: "${param}"`);
            if (param === '') {
                trainingModule.saveCourse(this.data);
                logEvent('Course data saved on terminate.');
            }
            return String(param === '');
        },

        SetValue(element, value) {
            this.errorCode = '0';
            let msg = `SetValue called for "${element}" with value "${value}"`;

            // Validate values for key SCORM 2004 fields
            const validationMsg = validateSCORMValue(element, value, "2004");
            if (validationMsg) {
                this.errorCode = '406';
                msg += ` [Validation error: ${validationMsg}]`;
                logEvent(msg);
                return 'false';
            }

            // Handle interactions
            const interactionMatch = element.match(/^cmi\.interactions\.(\d+)\.(\w+)$/);
            if (interactionMatch) {
                const idx = parseInt(interactionMatch[1], 10);
                const field = interactionMatch[2];

                if (!Array.isArray(this.data["cmi.interactions"])) {
                    this.data["cmi.interactions"] = [];
                }
                while (this.data["cmi.interactions"].length <= idx) {
                    this.data["cmi.interactions"].push({});
                }
                this.data["cmi.interactions"][idx][field] = value;
                this.data["cmi.interactions._count"] = String(this.data["cmi.interactions"].length);

                msg += ` (interaction index ${idx} field ${field})`;
            } else {
                // Watch for cmi.success_status changes
                if (element === "cmi.success_status") {
                    const prev = this.data[element];
                    if (prev !== value && typeof onSuccessStatusChange === "function") {
                        onSuccessStatusChange(value, prev);
                        msg += ` (cmi.success_status changed from "${prev}" to "${value}")`;
                    }
                }
                this.data[element] = value;
            }
            logEvent(msg);
            return "true";
        },

        GetValue(element) {
            this.errorCode = '0';
            let value = '';
            if (element === "cmi.interactions._count") {
                value = String(Array.isArray(this.data["cmi.interactions"]) ? this.data["cmi.interactions"].length : 0);
            } else {
                const match = element.match(/^cmi\.interactions\.(\d+)\.(\w+)$/);
                if (match) {
                    const idx = parseInt(match[1], 10);
                    const field = match[2];
                    if (
                        Array.isArray(this.data["cmi.interactions"]) &&
                        this.data["cmi.interactions"][idx] &&
                        this.data["cmi.interactions"][idx][field] !== undefined
                    ) {
                        value = this.data["cmi.interactions"][idx][field];
                    } else {
                        this.errorCode = '401';
                        value = '';
                    }
                } else {
                    value = this.data[element] !== undefined ? String(this.data[element]) : '';
                }
            }
            logEvent(`GetValue called for "${element}": "${value}"`);
            return value;
        },

        Commit() {
            this.errorCode = '0';
            logEvent('Commit called. Data committed.');
            trainingModule.saveCourse(this.data);
            return 'true';
        },

        GetLastError() {
            logEvent(`GetLastError called. Error: "${this.errorCode}"`);
            return this.errorCode;
        },

        GetErrorString(errorCode) {
            let errorString = '';
            switch (errorCode) {
                case '0': errorString = 'No error'; break;
                case '101': errorString = 'General exception'; break;
                case '201': errorString = 'Invalid argument error'; break;
                case '202': errorString = 'Element cannot have children'; break;
                case '203': errorString = 'Element not an array. Cannot have count.'; break;
                case '301': errorString = 'Not initialized'; break;
                case '401': errorString = 'Not implemented error'; break;
                case '402': errorString = 'Invalid set value, element is a keyword'; break;
                case '406': errorString = 'Data Model Element Type Mismatch'; break;
                default: errorString = 'Unknown error';
            }
            logEvent(`GetErrorString called for "${errorCode}": "${errorString}"`);
            return errorString;
        },
    };
})();